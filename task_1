"""
Задание 1.

Выполните профилирование памяти в скриптах
Проанализировать результат и определить программы с
наиболее эффективным использованием памяти.

Примечание: Для анализа возьмите любые 1-5 ваших разных скриптов!.
Сделать их разные реализации.

Можно взять задачи с курса Основ
или с текущего курса Алгоритмов

Результаты анализа вставьте в виде комментариев к коду.
Также укажите в комментариях версию Python и разрядность вашей ОС.

ВНИМАНИЕ: ЗАДАНИЯ, В КОТОРЫХ БУДУТ ГОЛЫЕ ЦИФРЫ ЗАМЕРОВ (БЕЗ АНАЛИТИКИ)
БУДУТ ПРИНИМАТЬСЯ С ОЦЕНКОЙ УДОВЛЕТВОРИТЕЛЬНО

Попытайтесь дополнительно свой декоратор используя ф-цию memory_usage из memory_profiler
С одновременным замером времени (timeit.default_timer())!
"""
import random
from memory_profiler import profile
"""
версию Python - 3.8
разрядность ОС - Windows x64
"""


# 1.1 Пример наполнения списка

@profile
def function_1():
    array = list(range(100000))
    return array


function_1()
"""Line #    Mem usage    Increment  Occurences   Line Contents
============================================================
    34     15.6 MiB     15.6 MiB           1   @profile
    35                                         def function_1():
    36     17.5 MiB      1.9 MiB           1       array = list(range(100000))
    37     17.5 MiB      0.0 MiB           1       return array
"""


# 1.2 Пример наполнения списка
@profile
def function_2():
    i = 0
    array = []
    while i < 100000:
        array.append(i)
        i += 1
    return array


function_2()
"""Line #    Mem usage    Increment  Occurences   Line Contents
============================================================
    43     15.9 MiB     15.9 MiB           1   @profile
    44                                         def function_2():
    45     15.9 MiB      0.0 MiB           1       i = 0
    46     15.9 MiB      0.0 MiB           1       array = []
    47     18.4 MiB      0.2 MiB      100001       while i < 100000:
    48     18.4 MiB      0.8 MiB      100000           array.append(i)
    49     18.4 MiB      1.6 MiB      100000           i += 1
    50     18.4 MiB      0.0 MiB           1       return array
    
Вывод: В примере 1.2 памяти расходуется больше на 0,7 MiB.
Это особенно заметно при работе с большими значениями чисел. Еще раз убеждаемся, что использовать
встроенные функции эффективнее не только по скорости, но и по памяти.
"""


# 1.3 Пример прохождения списка и вывод элементов исходного списка, значения которых больше предыдущего элемента.
# Используя генераторное выражение, функцию enumerate и просто цикл с увеличивающейся переменной.
@profile
def function_3():
    my_list = []
    array_1 = []
    while len(my_list) < 50000:
        my_list.append(random.randint(1000000000000000000, 10000000000000000000000000000000000000000000))
        while my_list.count(my_list[-1]) > 1:
            del my_list[-1]
            my_list.append(random.randint(1000000000000000000, 10000000000000000000000000000000000000000000))
    array = [el_1 for i, el_1 in enumerate(my_list, 0) if (el_1 > my_list[i - 1]) and (i != 0)]
    array = array_1

    array_2 = []
    for i, el_2 in enumerate(my_list):
        if el_2 > my_list[i - 1] and i != 0:
            array.append(el_2)
    array = array_2

    array_3 = []
    i = 1
    for el_3 in my_list:
        if el_3 > my_list[i - 1] and i != 0:
            array.append(el_3)
        i += 1
    array = array_3
    return array


function_3()
"""
Line #    Mem usage    Increment  Occurences   Line Contents
============================================================
    80     16.4 MiB     16.4 MiB           1   @profile
    81                                         def function_3():
    82     16.4 MiB      0.0 MiB           1       my_list = []
    83     16.4 MiB      0.0 MiB           1       array_1 = []
    84     18.0 MiB      0.0 MiB       50001       while len(my_list) < 50000:
    85     18.0 MiB      1.5 MiB       50000           my_list.append(random.randint(1000000000000000000, 
                                                                        10000000000000000000000000000000000000000000))
    86     18.0 MiB      0.0 MiB       50000           while my_list.count(my_list[-1]) > 1:
    87                                                     del my_list[-1]
    88                                                     my_list.append(random.randint(1000000000000000000, 
                                                                        10000000000000000000000000000000000000000000))
    89     18.0 MiB      0.0 MiB       50003       array = [el_1 for i, el_1 in enumerate(my_list, 0) 
                                                                                if (el_1 > my_list[i - 1]) and (i != 0)]
    90     18.0 MiB      0.0 MiB           1       array = array_1
    91                                         
    92     18.0 MiB      0.0 MiB           1       array_2 = []
    93     18.0 MiB  -1018.1 MiB       50001       for i, el_2 in enumerate(my_list):
    94     18.0 MiB  -1018.0 MiB       50000           if el_2 > my_list[i - 1] and i != 0:
    95     18.0 MiB   -511.4 MiB       25084               array.append(el_2)
    96     17.9 MiB     -0.1 MiB           1       array = array_2
    97                                         
    98     17.9 MiB      0.0 MiB           1       array_3 = []
    99     17.9 MiB      0.0 MiB           1       i = 1
   100     17.9 MiB      0.0 MiB       50001       for el_3 in my_list:
   101     17.9 MiB      0.0 MiB       50000           if el_3 > my_list[i - 1] and i != 0:
   102                                                     array.append(el_3)
   103     17.9 MiB      0.0 MiB       50000           i += 1
   104     17.9 MiB      0.0 MiB           1       array = array_3
   105     17.9 MiB      0.0 MiB           1       return array

Вывод: Под профилирование было выделено 16,4 MiB. Далее создался массив и выделилось еще 1,5 MiB.
Генераторное выражение с периодичностью запуска кода добавляло 0,1 MiB. 
Во втором варианте получения массива из значений, которые больше предыдущего элемента,
использовалась функция enumerate и Increment показывает огромные отрицательные значения. При этом
снижает выделенную память только строка 96 на 0.1 MiB. Далее изменений с памятью не происходят.
"""
