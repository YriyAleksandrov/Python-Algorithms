"""
Задание 1.

Приведен код, который позволяет сохранить в
массиве индексы четных элементов другого массива

Сделайте замеры времени выполнения кода с помощью модуля timeit

Попробуйте оптимизировать код, чтобы снизить время выполнения
Проведите повторные замеры

Добавьте аналитику: что вы сделали и почему
"""
from timeit import timeit


def func_1(num):
    new_arr = []
    for i in range(len(num)):
        if num[i] % 2 == 0:
            new_arr.append(i)
    return new_arr


def func_2(num):
    return [i for i, el, in enumerate(num) if el % 2 == 0]


nums_1 = [el for el in range(1000)]
print(timeit('func_1(nums_1)', setup='from __main__ import func_1, nums_1', number=1000))
print(timeit('func_2(nums_1)', setup='from __main__ import func_2, nums_1', number=1000))
"""
0.1542384 сек
0.10244090000000003 сек
"""

nums_2 = [el for el in range(100000)]
print(timeit('func_1(nums_2)', setup='from __main__ import func_1, nums_2', number=1000))
print(timeit('func_2(nums_2)', setup='from __main__ import func_2, nums_2', number=1000))
"""
19.223193600000002 сек
14.386861800000002 сек
"""

nums_3 = [el for el in range(1000000)]
print(timeit('func_1(nums_3)', setup='from __main__ import func_1, nums_3', number=1000))
print(timeit('func_2(nums_3)', setup='from __main__ import func_2, nums_3', number=1000))
"""
213.3324447 сек
166.85120830000002 сек
"""


"""
Вывод: Уход от функции .append и использование генераторного выражения ускорило выполнение кода.
Это заметно и на маленьком кол-ве значений в массиве и на большом.
При этом сложность осталась единой O(n)"""