"""
Задание 2.

Приведен код, который формирует из введенного числа
обратное по порядку входящих в него цифр.
Задача решена через рекурсию

Сделайте замеры времени выполнения кода с помощью модуля timeit

Попробуйте оптимизировать код, чтобы снизить время выполнения
Проведите повторные замеры

Подсказка: примените мемоизацию

Добавьте аналитику: что вы сделали и почему
"""
from timeit import timeit
from random import randint


def recursive_reverse(number):
    if number == 0:
        return str(number % 10)
    return f'{str(number % 10)}{recursive_reverse(number // 10)}'


def memoization(n):
    my_dict = {}

    def decorate(*args):
        if args in my_dict:
            return my_dict[args]
        else:
            my_dict[args] = n(*args)
            return my_dict[args]
    return decorate


@memoization
def optimize_reverse(number):
    if number == 0:
        return ' '
    return f'{str(number % 10)}{optimize_reverse(number // 10)}'


num_1 = randint(1000, 100000)
print(f"Замер изначального кода с числом: {num_1} - "
      f"{timeit('recursive_reverse(num_1)', setup='from __main__ import recursive_reverse, num_1', number=1000)} сек")
print(f"Замер оптимизированного кода с числом: {num_1} - "
      f"{timeit('optimize_reverse(num_1)', setup='from __main__ import optimize_reverse, num_1', number=1000)} сек")
print('')

num_2 = randint(100000, 100000000)
print(f"Замер изначального кода с числом: {num_2} - "
      f"{timeit('recursive_reverse(num_2)', setup='from __main__ import recursive_reverse, num_2', number=1000)} сек")
print(f"Замер оптимизированного кода с числом: {num_2} - "
      f"{timeit('optimize_reverse(num_2)', setup='from __main__ import optimize_reverse, num_2', number=1000)} сек")
print('')

num_3 = randint(100000000, 100000000000)
print(f"Замер изначального кода с числом: {num_3} - " 
      f"{timeit('recursive_reverse(num_3)', setup='from __main__ import recursive_reverse, num_3', number=1000)} сек")
print(f"Замер оптимизированного кода с числом: {num_3} - "
      f"{timeit('optimize_reverse(num_3)', setup='from __main__ import optimize_reverse, num_3', number=1000)} сек")

"""
Вывод: Оптимизированный код на порядок увеличивает скорость обработки данных.
Связано это с тем, что мы не слепо перебераем каждую цифру, а записываем цифры в словарь и при 
попадании на уже записанную цифру, вынимаем её по ключу. Это удобно и быстро.
Особенно хорошо заметно на длинных числах, где шанс повторения цифр выше."""
